{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","js/flashVPAID.js"],"names":[],"mappings":"AAAA;ACAA","file":"flashVPAID.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","//if this code already run once don't do anything\nif (window.FlashVPAID) return;\n\nlet IVPAID = require('./IVPAID').IVPAID;\nlet noop = require('./utils').noop;\nlet unique = require('./utils').unique;\nlet uniqueVPAID = unique('vpaid');\nlet instances = {};\nconst VPAID_FLASH_HANDLER = 'vpaid_video_flash_handler';\n\nfunction createElementWithID(parent, id) {\n    var nEl = document.createElement('div');\n    nEl.id = id;\n    parent.innerHTML = '';\n    parent.appendChild(nEl);\n    return nEl;\n}\n\nclass FlashVPAID extends IVPAID {\n    constructor (vpaidWrapper, callback, swfConfig = {data: 'VPAIDFlash.swf', width: 800, height: 400}, version = '9', params = { wmode: 'transparent', salign: 'tl', allowScriptAccess: 'always'}, debug = false) {\n        super();\n        this._handlers = {};\n        this._callbacks = {};\n\n        this.vpaidWrapper = vpaidWrapper;\n        this.flashID = uniqueVPAID();\n        this.load =  callback || noop;\n        this._uniqueMethodIdentifier = unique(flashID);\n        createElementWithID(vpaidWrapper, this.flashID);\n\n        //because flash externalInterface will call\n        instances[this.flashID] = this;\n\n        params.movie = swfConfig.data;\n        params.FlashVars = `flashid=${this.flashID}&handler=${VPAID_FLASH_HANDLER}&debug=${debug}`;\n\n        if (swfobject.hasFlashPlayerVersion(version)) {\n            this.el = swfobject.createSWF(swfConfig, params, this.flashID);\n        }\n\n        //if this.el is undefined means swfobject failed to create the swfobject\n        if (!this.el) return this;\n    }\n\n    _safeFlashMethod(methodName, args = [], callbacks = undefined) {\n        var callbackID = '';\n        // if no callback, some methods the return is void so they don't need callback\n        if (callback) {\n            var callbackID = this.uniqueMethodIdentifier();\n            this._callbacks[callbackID] = callback;\n        }\n\n        try {\n            this.el[methodName].call(this, [this.flashID, methodName, callbackID].concat(args));\n\n        } catch (e) {\n            if (callback) {\n                delete this.callback[callbackID];\n                callback(e);\n            } else {\n\n                //if there isn't any callback to return error use error event handler\n                _fireEvent('error', [e]);\n            }\n        }\n    }\n\n    _flashMethodAnswer(methodName, callbackID, args) {\n\n        //method's that return void will not have callbacks\n        if (callbackID === '') return;\n\n        if (!this._callbacks[callbackID]) {\n            //TODO: something is wrong, this should never happens if it happens fire an error\n            return;\n        }\n\n        //TODO: check with carlos if we need to use apply instead\n        this._callbacks[callbackID](args);\n        delete this._callbacks[callbackID];\n    }\n\n    _fireEvent(eventName, args) {\n        //TODO: check if forEach and isArray is added to the browser with babeljs\n        if (Array.isArray(this._handlers[eventName])) {\n            this._handlers[eventName].forEach(function (callback) {\n                setTimeout(function () {\n                    callback(args);\n                }, 0);\n            });\n        }\n    }\n\n    on(eventName, callback) {\n        if (!this._handlers[eventName]) {\n            this._handlers[eventName] = [];\n        }\n        this._handlers[eventName].push(callback);\n    }\n\n    //async methods\n    handshakeVersion(callback, playerVPAIDVersion = '2.0') {\n        _safeFlashMethod('handshakeVersion', [playerVPAIDVersion], callback);\n    }\n\n    initAd (viewMode, desiredBitrate, width = 0, height = 0, creativeData = '', environmentVars = '') {\n        this.size(width, height);\n        _safeFlashMethod('initAd', [this.getWidth(), this.getHeight(), viewMode, desiredBitrate, creativeData, environmentVars]);\n    }\n\n    resizeAd(width, height, viewMode) {\n        this.size(width, height);\n        _safeFlashMethod('resizeAd', [this.getWidth(), this.getHeight(), viewMode]);\n    }\n\n    startAd() {\n        _safeFlashMethod('startAd');\n    }\n    stopAd() {\n        _safeFlashMethod('stopAd');\n    }\n    pauseAd() {\n        _safeFlashMethod('pauseAd');\n    }\n    resumeAd() {\n        _safeFlashMethod('resumeAd');\n    }\n    expandAd() {\n        _safeFlashMethod('expandAd');\n    }\n    collapseAd() {\n        _safeFlashMethod('collapseAd');\n    }\n    skipAd() {\n        _safeFlashMethod('skipAd');\n    }\n\n    //properties that will be treat as async methods\n    adLinear() {}\n    adWidth() {}\n    adHeight() {}\n    adExpanded() {}\n    adSkippableState() {}\n    adRemainingTime() {}\n    adDuration() {}\n    adVolume() {}\n    adCompanions() {}\n    adIcons() {}\n\n    _flash_handShake (message) {\n        console.log('handShake:', message);\n        if (message == 'prepared') {\n            this.load();\n        }\n    }\n\n}\n\nwindow[VPAID_FLASH_HANDLER] = function (flashID, event, message) {\n    console.log('flashID', flashID, 'event', event, 'message', message);\n    //console.log(instances[flashID], instances[flashID]['_flash_']);\n    instances[flashID]['_flash_' + event](message);\n}\nwindow.FlashVPAID = FlashVPAID;\n\n"]}